/*
 * Copyright (C) 2015, The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "options.h"

#include <cstring>
#include <iostream>
#include <stdio.h>

#include "logging.h"
#include "os.h"

using std::cerr;
using std::endl;
using std::string;
using std::unique_ptr;
using std::vector;

namespace android {
namespace aidl {

Options::Result Options::ParseFlag(int index, const std::string& arg) {
  if (arg.size() < 2) return Result::UNHANDLED;
  if (arg[0] != '-') return Result::UNHANDLED;

  if (arg[1] == 'I') {
    if (arg.size() > 2) {
      this->import_paths_.push_back(arg.substr(2));
      return Result::CONSUMED;
    } else {
      fprintf(stderr, "-I option (%d) requires a path.\n", index);
      return Result::ERROR;
    }
  }

  if (arg[1] == 'd') {
    if (arg.size() > 2) {
      this->dep_file_name_ = arg.substr(2);
      return Result::CONSUMED;
    } else {
      fprintf(stderr, "-d option (%d) requires a file.\n", index);
      return Result::ERROR;
    }
  }

  if (arg == "--ninja") {
    this->dep_file_ninja_ = true;
    return Result::CONSUMED;
  }

  if (arg == "-t") {
    this->gen_traces_ = true;
    return Result::CONSUMED;
  }

  if (arg[1] == 'p') {
    if (arg.size() > 2) {
      this->preprocessed_files_.push_back(arg.substr(2));
      return Result::CONSUMED;
    } else {
      fprintf(stderr, "-p option (%d) requires a file.\n", index);
      return Result::ERROR;
    }
  }

  return Result::UNHANDLED;
}

void Options::FlagUsage() {
  cerr << "   -I<DIR>    search path for import statements" << endl
       << "   -p<FILE>   file created by --preprocess to import." << endl
       << "   -d<FILE>   generate dependency file" << endl
       << "   -t         include tracing code for systrace. Note that if the client or server code "
          "is not auto-generated by this tool, that part will not be traced."
       << endl
       << "   --ninja    generate dependency file in a format ninja understands" << endl;
}

unique_ptr<JavaOptions> JavaOptions::Usage() {
  fprintf(stderr,
          "usage: aidl OPTIONS INPUT [OUTPUT]\n"
          "       aidl --preprocess OUTPUT INPUT...\n"
          "       aidl --dumpapi OUTPUT INPUT...\n"
          "\n"
          "OPTIONS:\n");
  this->FlagUsage();
  fprintf(stderr,
          "\n"
          "INPUT:\n"
          "   An aidl interface file.\n"
          "\n"
          "OUTPUT:\n"
          "   The generated interface files.\n"
          "   If omitted and the -o option is not used, the input filename is "
          "used, with the .aidl extension changed to a .java extension.\n"
          "   If the -o option is used, the generated files will be placed in "
          "the base output folder, under their package folder\n");
  return unique_ptr<JavaOptions>(nullptr);
}

Options::Result JavaOptions::ParseFlag(int index, const std::string& arg) {
  Result parent = Options::ParseFlag(index, arg);
  if (parent != Result::UNHANDLED) return parent;

  if (arg.size() < 2) return Result::UNHANDLED;
  if (arg[0] != '-') return Result::UNHANDLED;

  if (arg == "-a") {
    this->auto_dep_file_ = true;
    return Result::CONSUMED;
  }

  if (arg[1] == 'o') {
    if (arg.size() > 2) {
      this->output_base_folder_ = arg.substr(2);
      return Result::CONSUMED;
    } else {
      fprintf(stderr, "-o option (%d) requires a path.\n", index);
      return Result::ERROR;
    }
  }

  if (arg == "-b") {
    this->fail_on_parcelable_ = true;
    return Result::CONSUMED;
  }

  if (arg == "--transaction_names") {
    this->gen_transaction_names_ = true;
    return Result::CONSUMED;
  }

  return Result::UNHANDLED;
}

void JavaOptions::FlagUsage() {
  Options::FlagUsage();
  cerr << "   -a         generate dependency file next to the output file with the name based on "
          "the input file."
       << endl
       << "   -o<FOLDER> base output folder for generated files." << endl
       << "   -b         fail when trying to compile a parcelable." << endl
       << "   --transaction_names  generate method to resolve a binder method code to the original "
          "method name."
       << endl;
}

unique_ptr<JavaOptions> JavaOptions::Parse(int argc, const char* const* argv) {
  unique_ptr<JavaOptions> options(new JavaOptions());
  int i = 1;

  if (argc >= 2) {
    if (argc < 4) {
      return options->Usage();
    }
    options->output_file_name_ = argv[2];
    for (int i = 3; i < argc; i++) {
      options->input_file_names_.push_back(argv[i]);
    }
    if (0 == strcmp(argv[1], "--preprocess")) {
      options->task = PREPROCESS_AIDL;
      return options;
    } else if (0 == strcmp(argv[1], "--dumpapi")) {
      options->task = DUMP_API;
      return options;
    }
  }

  options->task = COMPILE_AIDL_TO_JAVA;
  // OPTIONS
  for (; i < argc; i++) {
    const char* s = argv[i];

    Result res = options->ParseFlag(i, s);
    if (res == Result::ERROR) return options->Usage();
    if (res == Result::UNHANDLED) {
      if (s[0] == '-') {
        cerr << "unknown option (" << i << "): " << s << endl;
        return options->Usage();
      }
      break;  // On to the positional arguments
    }
    CHECK(res == Result::CONSUMED);
  }
  // INPUT
  if (i < argc) {
    options->input_file_name_ = argv[i];
    i++;
  } else {
    fprintf(stderr, "INPUT required\n");
    return options->Usage();
  }
  if (!EndsWith(options->input_file_name_, ".aidl")) {
    cerr << "Expected .aidl file for input but got "
         << options->input_file_name_ << endl;
    return options->Usage();
  }

  // OUTPUT
  if (i < argc) {
    options->output_file_name_ = argv[i];
    i++;
  } else if (options->output_base_folder_.empty()) {
    // copy input into output and change the extension from .aidl to .java
    options->output_file_name_= options->input_file_name_;
    if (!ReplaceSuffix(".aidl", ".java", &options->output_file_name_)) {
      // we should never get here since we validated the suffix.
      LOG(FATAL) << "Internal aidl error.";
      return options->Usage();
    }
  }

  // anything remaining?
  if (i != argc) {
    fprintf(stderr, "unknown option%s:",
            (i == argc - 1 ? (const char*)"" : (const char*)"s"));
    for (; i < argc - 1; i++) {
      fprintf(stderr, " %s", argv[i]);
    }
    fprintf(stderr, "\n");
    return options->Usage();
  }

  return options;
}

string JavaOptions::DependencyFilePath() const {
  if (auto_dep_file_) {
    return output_file_name_ + ".d";
  }
  return dep_file_name_;
}

unique_ptr<CppOptions> CppOptions::Usage() {
  cerr << "usage: aidl-cpp INPUT_FILE HEADER_DIR OUTPUT_FILE" << endl << endl << "OPTIONS:" << endl;
  this->FlagUsage();
  cerr << endl
       << "INPUT_FILE:" << endl
       << "   an aidl interface file" << endl
       << "HEADER_DIR:" << endl
       << "   empty directory to put generated headers" << endl
       << "OUTPUT_FILE:" << endl
       << "   path to write generated .cpp code" << endl;
  return unique_ptr<CppOptions>(nullptr);
}

unique_ptr<CppOptions> CppOptions::Parse(int argc, const char* const* argv) {
  unique_ptr<CppOptions> options(new CppOptions());
  int i = 1;

  // Parse flags, all of which start with '-'
  for ( ; i < argc; ++i) {
    const char *s = argv[i];

    Result res = options->ParseFlag(i, s);
    if (res == Result::ERROR) return options->Usage();
    if (res == Result::UNHANDLED) {
      if (s[0] == '-') {
        cerr << "unknown option (" << i << "): " << s << endl;
        return options->Usage();
      }
      break;  // On to the positional arguments
    }
    CHECK(res == Result::CONSUMED);
  }

  // There are exactly three positional arguments.
  const int remaining_args = argc - i;
  if (remaining_args != 3) {
    cerr << "Expected 3 positional arguments but got " << remaining_args << "." << endl;
    return options->Usage();
  }

  options->input_file_name_ = argv[i];
  options->output_header_dir_ = argv[i + 1];
  options->output_file_name_ = argv[i + 2];

  if (!EndsWith(options->input_file_name_, ".aidl")) {
    cerr << "Expected .aidl file for input but got " << options->input_file_name_ << endl;
    return options->Usage();
  }

  return options;
}

bool EndsWith(const string& str, const string& suffix) {
  if (str.length() < suffix.length()) {
    return false;
  }
  return std::equal(str.crbegin(), str.crbegin() + suffix.length(),
                    suffix.crbegin());
}

bool ReplaceSuffix(const string& old_suffix,
                   const string& new_suffix,
                   string* str) {
  if (!EndsWith(*str, old_suffix)) return false;
  str->replace(str->length() - old_suffix.length(),
               old_suffix.length(),
               new_suffix);
  return true;
}



}  // namespace android
}  // namespace aidl
